Now, let's try asking an agent to write come code and commit the resulting code to the current branch of this repository.

To do that, let's give the agent the necessary tools it will need which in this case will be python functions that perform different github actions using the `subprocess` package.
We'll follow the basic steps for building a langchain agent:

# Steps for building a simple agent:
- Set up the LLM
- Define the tool or toolkit (list of tools)
- Set up a prompt template
- Connect llm with your tools
- Define your agent as a dict with keys: input, and agent scratchpad 
- Use the Langchain LCEL language to pipe agent, prompt the llm_with_tools variable and the output parser (which can use OpenAI function calling parser)
- Create the agent loop
- Wrap everything into the AgentExecutor
- Invoke the agent with some query input

# setup the llm
from langchain.chat_models import ChatOpenAI

llm = ChatOpenAI(temperature=0)
Now, let's create a tool for the LLM
import subprocess

def github_commit_tool(commit_message="Some commit"):
    subprocess.run(["git", "add", "."])
    subprocess.run(["git", "commit", "-m", commit_message])
    subprocess.run(["git", "push", "-u", "origin", "main"])
    
    return "Committed to Github"
Now! Before we use it with langchain, let's test it by itself.
github_commit_tool("Some testing commit")
Now, let's take a look at out github repository from the terminal.

Nice! It looks like we are good to go with this first simple tool!
Let's now make it a tool for our langchain agent by adding the @tool. 
from langchain.tools import tool

@tool
def github_commit_tool(commit_message="Some commit"):
    """This function uses the subprocess package to make commits to a github repo pre-defined."""
    subprocess.run(["git", "add", "."])
    subprocess.run(["git", "commit", "-m", commit_message])
    subprocess.run(["git", "push", "-u", "origin", "main"])
    
    return "Committed to Github"

tools = [github_commit_tool]
We added some documentation to our function to abide by the requirements of the tool decorator from langchain.
Now, let's test if a simple agent can use that tool!
Let's start by setting up our prompt template.
from langchain.agents import initialize_agent
from langchain.agents import AgentType

agent_executor = initialize_agent(
    tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True
)
agent_executor.invoke(
    {
        "input": "Make a commit to our github repo with the message: 'testing commits with langchain agent'"
    }
)
And voila! We made a commit!

Ok, this is cool but, we can go beyond that, and add the ability to create a file and then commit that file to our desired repository. Let's do that!

To do it all we have to do is amplify the Agent's toolkit with another tool that can create files in the current folder.
def create_file_tool(file_contents):
    with open("file.py", "w") as f:
        f.write(file_contents)
    
    return "File created"
Let's test this function with some contents generated by an llm model:
contents = llm.predict("Write Python code for summing two numbers. Output ONLY THE CODE")
Now, let's get the contents from the output of the llm and feed that to the agent along with a file name.
create_file_tool(contents)
Let's check the file was created and can be run from terminal
!ls *.py
!python ./file.py
Perfect! Now, let's add this to our github agent
@tool
def create_file_tool(file_contents):
    """This function creates a file with the contents and file path provided as inputs."""
    with open("file.py", "w") as f:
        f.write(file_contents)
    
    return "File created"
Now, let's add that functionality to our agent by just updating the tools list.
tools = [github_commit_tool, create_file_tool]
Now, let's modify our agent with its new toolkit
agent_executor = initialize_agent(
    tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True
)
Now, let's try using both tools in a call to see if the agent can do something slightly more complex now.
agent_executor.invoke({
    "input": "Write Python code for summing two numbers. Output ONLY THE CODE and save that to a file then commit it to our github repository."
})


Let's do that to modify our current tool: `create_file_tool()` to accept the file's contents as well as a file path, this way we are not restricted in creating just one type of file with a pre-specified name.
from langchain.tools import StructuredTool

def create_file_tool(file_contents: str, file_path: str) -> str:
    """
    Function that creates a file with the contents 
    and file path provided as inputs.
    """
    with open(file_path, "w") as f:
        f.write(file_contents)
    
    return "File created"

# Let's test it first!
create_file_tool("print('Hello World')", "print_file.py")
!ls *.py

Now, let's make it a tool for the agent.

create_file_tool = StructuredTool.from_function(create_file_tool)
And, again, let's update our toolkit and our agent.
tools = [github_commit_tool, create_file_tool]
agent_executor = initialize_agent(
    tools,
    llm,
    agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True,
)
Now, let's test it by asking it to write a simple `README.md` file, giving the agent some context about the project's repo.
agent_executor.invoke({
    "input": "Write a README.md file with a simple description of this project, which is about an introduction to langchain, then commit it to our github repo."
})


Ok, before we finish with this example, let's add a last tool to read files from a repo, for situations where we might write some Python code and we want our agent to integrate that Python code into our repository. 
Again, we follow the same procedure.
- Run a test task to check if it works 
def read_file_tool(file_path):
    with open(file_path, "r") as f:
        contents = f.read()
    
    return contents

read_file_tool("README.md")
Ok, our function seems to work so let's add it to our toolkit, since its a simple function with only one input we can just add the @tool decorator on top of it.
@tool
def read_file_tool(file_path):
    """
    Simple function to read contents from a file.
    """
    with open(file_path, "r") as f:
        contents = f.read()
    
    return contents

tools = [github_commit_tool, create_file_tool, read_file_tool]
And we update our agent
agent_executor = initialize_agent(tools, llm, 
                                  agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
                                  verbose=True
                                  )
agent_executor.invoke(
    {
    "input": "Update our README.md file based on the contents of the `langchain_github_agent.ipynb` notebook file, then commit the changes to github repo."
    }
                      )